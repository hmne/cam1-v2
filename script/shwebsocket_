#!/usr/bin/env bash
#===============================================================================
# WEBSOCKET CLIENT - Optional Real-time Communication
#
# This script is OPTIONAL. If not present or fails, system uses HTTP mode.
# Follows same pattern as main.sh, sync.sh, monitor.sh
#
# To enable: Set WS_SERVER environment variable in boot.sh
# To disable: Don't set WS_SERVER (or set to empty)
#===============================================================================
set -euo pipefail
IFS=$'\n\t'

#===============================================================================
# CONFIG
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="${BASE_URL:-http://netstorm.site/${DEVICE_ID}}"
readonly WS_SERVER="${WS_SERVER:-}"  # Empty = disabled
readonly HEARTBEAT_SEC=3

# Paths (same as other scripts)
readonly TMP_DIR="/var/tmp"
readonly LOG_FILE="/var/log/websocket.log"
readonly STATUS_FILE="${TMP_DIR}/status.tmp"
readonly VAR_FILE="${TMP_DIR}/var.tmp"
readonly PIC_FILE="${TMP_DIR}/pic.jpg"
readonly LIVE_FILE="${TMP_DIR}/web_live.tmp"

#===============================================================================
# SAFETY CHECK - Exit cleanly if not enabled
#===============================================================================
[[ -z "$WS_SERVER" ]] && {
    echo "WebSocket disabled (WS_SERVER not set) - using HTTP mode"
    exit 0
}

command -v websocat &>/dev/null || {
    echo "websocat not installed - using HTTP mode"
    exit 0
}

#===============================================================================
# LOGGING
#===============================================================================
log() {
    local msg="[$(date '+%H:%M:%S')] $1"
    echo "$msg"
    echo "$msg" >> "$LOG_FILE" 2>/dev/null || true
}

#===============================================================================
# SYSTEM STATUS (same as monitor.sh)
#===============================================================================
get_status() {
    local mem temp ping wifi

    mem=$(free -m 2>/dev/null | awk '/Mem:/ {printf "%.0f%%", $3/$2*100}' || echo "N/A")

    if [[ -f /sys/class/thermal/thermal_zone0/temp ]]; then
        temp=$(awk '{printf "%.1fC", $1/1000}' /sys/class/thermal/thermal_zone0/temp 2>/dev/null || echo "N/A")
    else
        temp="N/A"
    fi

    ping=$(ping -c 1 -W 2 8.8.8.8 2>/dev/null | grep -oP 'time=\K[\d.]+' || echo "N/A")
    [[ "$ping" != "N/A" ]] && ping="${ping}ms"

    wifi=$(iwconfig 2>/dev/null | grep -oP 'Link Quality=\K\d+/\d+' || echo "")
    if [[ -n "$wifi" ]]; then
        local n d
        n=${wifi%/*}
        d=${wifi#*/}
        wifi=$(awk "BEGIN {printf \"%.0f%%\", ($n/$d)*100}")
    else
        wifi="N/A"
    fi

    echo "${mem},${temp},${ping},${wifi}"
}

#===============================================================================
# CAPTURE IMAGE (same logic as main.sh)
#===============================================================================
do_capture() {
    local id="$1"
    local start_ms
    start_ms=$(date +%s%3N)

    log "Capture: $id"

    # Read settings (same format as main.sh)
    local w=1920 h=1080 q=75 r=0
    if [[ -f "$VAR_FILE" ]]; then
        local -a s
        read -r -a s < "$VAR_FILE" 2>/dev/null || true
        case "${s[0]:-1}" in
            1) w=1280; h=960 ;;
            2) w=1920; h=1080 ;;
            3) w=2592; h=1944 ;;
            4) w=3200; h=2400 ;;
        esac
        q=$((100 - ${s[1]:-25}))
        r="${s[4]:-0}"
    fi

    # Capture
    if ! raspistill -w "$w" -h "$h" -q "$q" -rot "$r" -t 1 -n -o "$PIC_FILE" 2>/dev/null; then
        log "raspistill failed"
        return 1
    fi

    # Upload via curl (same as sync.sh)
    if ! curl -sf -F "upfile=@${PIC_FILE}" "${BASE_URL}/storage.php" -m 30 >/dev/null 2>&1; then
        log "Upload failed"
        return 1
    fi

    local duration=$(( $(date +%s%3N) - start_ms ))
    log "Capture done: ${duration}ms"

    # Send response
    echo "{\"type\":\"capture_done\",\"id\":\"$id\",\"url\":\"pic.jpg\",\"duration\":$duration}"
}

#===============================================================================
# MESSAGE HANDLER
#===============================================================================
handle_msg() {
    local msg="$1"
    local type
    type=$(echo "$msg" | grep -oP '"type"\s*:\s*"\K[^"]+' || echo "")

    case "$type" in
        capture)
            local cid
            cid=$(echo "$msg" | grep -oP '"id"\s*:\s*"\K[^"]+' || date +%s)
            do_capture "$cid" || echo "{\"type\":\"capture_error\"}"
            ;;

        settings)
            local data
            data=$(echo "$msg" | grep -oP '"data"\s*:\s*"\K[^"]+' || echo "")
            [[ -n "$data" ]] && echo "$data" > "$VAR_FILE"
            log "Settings updated"
            ;;

        live_start)
            echo "on" > "$LIVE_FILE"
            log "Live stream started"
            ;;

        live_stop)
            echo "off" > "$LIVE_FILE"
            log "Live stream stopped"
            ;;
    esac
}

#===============================================================================
# HEARTBEAT (background process)
#===============================================================================
send_heartbeats() {
    while true; do
        local s
        s=$(get_status)
        echo "{\"type\":\"heartbeat\",\"data\":\"$s\"}"
        echo "$s" > "$STATUS_FILE" 2>/dev/null || true
        sleep "$HEARTBEAT_SEC"
    done
}

#===============================================================================
# WEBSOCKET CONNECTION
#===============================================================================
ws_connect() {
    log "Connecting to $WS_SERVER"

    # Start heartbeat sender
    send_heartbeats | {
        # First message: identify as camera
        echo '{"type":"identify","role":"camera"}'

        # Forward heartbeats
        cat
    } | websocat -t "ws://${WS_SERVER}" 2>/dev/null | while read -r line; do
        # Handle incoming commands
        response=$(handle_msg "$line" 2>/dev/null)
        [[ -n "$response" ]] && echo "$response"
    done

    return 1  # Connection closed
}

#===============================================================================
# MAIN LOOP
#===============================================================================
main() {
    log "Starting WebSocket client for ${DEVICE_ID}"
    log "Server: ${WS_SERVER}"

    # Retry with backoff
    local delay=2
    while true; do
        if ws_connect; then
            delay=2
        else
            log "Connection failed, retry in ${delay}s"
        fi

        sleep "$delay"
        # Increase delay up to 30 seconds
        ((delay = delay < 30 ? delay * 2 : 30))
    done
}

# Cleanup on exit
cleanup() {
    log "Shutting down"
    jobs -p | xargs -r kill 2>/dev/null || true
}
trap cleanup EXIT INT TERM

main
