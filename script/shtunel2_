#!/usr/bin/env bash

#===============================================================================
# NGROK TUNNEL SCRIPT - Server 2
#===============================================================================
set -Eeuo pipefail


#===============================================================================
# CONFIG
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly T_MODE="${T_MODE:-both}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly MIN_VERSION="3.9.0"
readonly T_PORT="80"
readonly S_PORT="22"
readonly NGROK_TOKEN="2XDXsQpUatqtLsmWL8yvABPBZAc_4Nr3BoxJ51XvXcmZnqxBo"

readonly INSTALL_DIR="/usr/local/bin"
readonly TEMP_DIR="/tmp"
readonly URL_FILE="${TEMP_DIR}/url2.tmp"
readonly SSH_FILE="${TEMP_DIR}/ssh2.tmp"
readonly CONFIG_FILE="${TEMP_DIR}/ngrok.yml"
readonly LOG_FILE="${TEMP_DIR}/ngrok.log"
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly API_URL="http://127.0.0.1:4040/api/tunnels"

# Export for external use
export DEVICE_ID BASE_URL


#===============================================================================
# TRAP HANDLERS
#===============================================================================
cleanup() {
    local exit_code=${1:-$?}

    log "INFO" "Cleaning up ngrok processes"
    pkill -f ngrok 2>/dev/null || :
    rm -f "$URL_FILE" "$SSH_FILE"

    exit "$exit_code"
}


err_trap() {
    local exit_code=$? line="${BASH_LINENO[0]}" func="${FUNCNAME[1]:-main}"
    log "ERROR" "${func}():${line} failed (exit $exit_code)"
}


trap 'cleanup $?' EXIT INT TERM
trap err_trap ERR


#===============================================================================
# LOGGING
#===============================================================================
log() {
    local level="$1" msg="$2"
    local timestamp
    timestamp=$(TZ=Asia/Kuwait date '+%Y-%m-%d %H:%M:%S')
    printf '[%s] [%s] %s\n' "$timestamp" "$level" "$msg" | tee -a "$LOG_FILE"
}


#===============================================================================
# FUNCTIONS
#===============================================================================

# Version comparison
version_gt() {
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}


# Get ngrok version (Pure Bash)
get_version() {
    local version_output
    version_output=$(ngrok version 2>/dev/null) || { echo "0.0.0"; return; }

    # Extract version pattern after "version" keyword (e.g., version 3.9.0)
    if [[ $version_output =~ version[[:space:]]+([0-9]+\.[0-9]+\.[0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "0.0.0"
    fi
}


# Install ngrok with version check and file verification
install_ngrok() {
    local current_version

    if command -v ngrok &>/dev/null; then
        current_version=$(get_version)

        if ! version_gt "$MIN_VERSION" "$current_version"; then
            log "INFO" "Current ngrok version $current_version is up to date"
            return 0
        fi

        log "INFO" "Updating ngrok from version $current_version to $MIN_VERSION"
    else
        log "INFO" "ngrok not found, installing..."
    fi

    cd "$TEMP_DIR" || return 1

    local attempt

    for attempt in {1..3}; do
        log "INFO" "Download attempt $attempt/3 from custom source"

        if wget -q "$BASE_URL/downloads/ngrok.tgz" -O ngrok.tgz 2>/dev/null; then
            tar -xzf ngrok.tgz
            rm -f ngrok.tgz
            chmod +x ngrok

            # Verify file size (minimum 5MB)
            local file_size
            file_size=$(stat -c%s ngrok 2>/dev/null || echo 0)

            if [[ $file_size -ge 5242880 ]]; then
                sudo mv ngrok "$INSTALL_DIR/"
                log "INFO" "Successfully installed ngrok from custom source (${file_size} bytes)"
                return 0
            fi

            log "WARN" "Downloaded file too small ($file_size bytes), retry $attempt/3"
            rm -f ngrok
        fi

        sleep 1
    done

    log "INFO" "Trying official download"
    if wget -q "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-arm.tgz" -O ngrok.tgz 2>/dev/null; then
        tar -xzf ngrok.tgz
        rm -f ngrok.tgz
        chmod +x ngrok

        # Verify file size
        local file_size
        file_size=$(stat -c%s ngrok 2>/dev/null || echo 0)

        if [[ $file_size -ge 5242880 ]]; then
            sudo mv ngrok "$INSTALL_DIR/"
            log "INFO" "Successfully installed ngrok from official source (${file_size} bytes)"
            return 0
        fi
    fi

    log "ERROR" "Failed to install ngrok from any source"
    return 1
}


# Create ngrok configuration
create_config() {
    log "INFO" "Creating ngrok configuration"

    cat > "$CONFIG_FILE" <<EOF
version: 2
authtoken: $NGROK_TOKEN
region: eu
tunnels:
  http:
    proto: http
    addr: $T_PORT
  ssh:
    proto: tcp
    addr: $S_PORT
EOF

    log "INFO" "Configuration file created"
}


# Get tunnel URLs from ngrok API
get_urls() {
    local attempt success=false

    for attempt in $(seq 1 15); do
        if [[ $T_MODE != "tcp" ]]; then
            # Pure bash: extract HTTPS URL from JSON
            local api_response http_url=""
            api_response=$(curl -s "$API_URL" 2>/dev/null || :)

            while IFS= read -r line; do
                if [[ $line =~ \"(https://[^\"]+)\" ]]; then
                    http_url="${BASH_REMATCH[1]}"
                    break
                fi
            done <<< "$api_response"

            if [[ -n $http_url ]]; then
                echo "$http_url" > "$URL_FILE"
                log "INFO" "HTTP tunnel URL: $http_url"
                [[ $T_MODE == "http" ]] && success=true
            fi
        fi

        if [[ $T_MODE != "http" ]]; then
            # Pure bash: extract TCP URL from JSON
            local api_response tcp_url=""
            api_response=$(curl -s "$API_URL" 2>/dev/null || :)

            while IFS= read -r line; do
                if [[ $line =~ \"(tcp://[^\"]+)\" ]]; then
                    tcp_url="${BASH_REMATCH[1]}"
                    break
                fi
            done <<< "$api_response"

            if [[ -n $tcp_url ]]; then
                local tcp_details=${tcp_url#tcp://}
                echo "$tcp_details" > "$SSH_FILE"
                log "INFO" "SSH tunnel endpoint: $tcp_details"
                success=true
            fi
        fi

        [[ $success == true ]] && return 0

        sleep 2
    done

    log "WARN" "Failed to get tunnel URLs after 30 seconds"
    return 1
}


# Start tunnel with retry
start_tunnel() {
    local attempt

    # Clean up existing processes
    pkill -f ngrok 2>/dev/null || :
    rm -f "$URL_FILE" "$SSH_FILE"

    create_config

    for attempt in $(seq 1 "$MAX_RETRIES"); do
        log "INFO" "Starting ngrok tunnel (attempt $attempt/$MAX_RETRIES)"

        # Run ngrok config upgrade (non-blocking)
        ngrok config upgrade --config "$CONFIG_FILE" &>/dev/null || :
        ngrok config upgrade --relocate --config "$CONFIG_FILE" &>/dev/null || :

        case "$T_MODE" in
            "http")
                log "INFO" "Starting HTTP tunnel"
                ngrok start http --config "$CONFIG_FILE" &
                ;;

            "tcp")
                log "INFO" "Starting TCP tunnel"
                ngrok start ssh --config "$CONFIG_FILE" &
                ;;

            "both")
                log "INFO" "Starting both HTTP and TCP tunnels"
                ngrok start --all --config "$CONFIG_FILE" &
                ;;
        esac

        local ngrok_pid=$!
        log "INFO" "ngrok started with PID: $ngrok_pid"

        sleep 0.2  # Service startup delay

        if get_urls; then
            log "INFO" "Tunnel(s) established successfully"
            return 0
        fi

        log "WARN" "Tunnel attempt $attempt failed, cleaning up"

        # Clean up for retry
        pkill -f ngrok 2>/dev/null || :
        rm -f "$URL_FILE" "$SSH_FILE"

        if [[ $attempt -lt $MAX_RETRIES ]]; then
            log "INFO" "Waiting ${RETRY_DELAY}s before retry"
            sleep "$RETRY_DELAY"
        fi
    done

    log "ERROR" "Failed to establish tunnel after $MAX_RETRIES attempts"
    return 1
}


# Monitor tunnel health
monitor_tunnel() {
    log "INFO" "Starting tunnel monitoring"

    while true; do
        if ! pgrep -f ngrok >/dev/null 2>&1 || ! curl -s "$API_URL" &>/dev/null; then
            log "WARN" "ngrok process or API not responding, restarting"
            if ! start_tunnel; then
                log "ERROR" "Failed to restart tunnel"
            fi
        fi
        sleep 30
    done
}


#===============================================================================
# MAIN
#===============================================================================
main() {
    log "INFO" "=== SERVER 2 (NGROK) STARTING ==="

    if ! install_ngrok; then
        log "ERROR" "Server 2 installation failed"
        exit 1
    fi

    if ! start_tunnel; then
        log "ERROR" "Server 2 failed to start"
        exit 1
    fi

    log "INFO" "Server 2 is running"
    monitor_tunnel
}


main "$@"
