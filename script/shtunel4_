#!/usr/bin/env bash

#===============================================================================
# BORE TUNNEL SCRIPT - Server 4
#===============================================================================
set -Eeuo pipefail


#===============================================================================
# CONFIG
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly MIN_VERSION="0.5.1"
readonly T_PORT="80"
readonly CUSTOM_SERVER="193.160.119.136"
readonly CUSTOM_SECRET="NetStorm"

readonly INSTALL_DIR="/usr/local/bin"
readonly TEMP_DIR="/tmp"
readonly BORE_BIN="${INSTALL_DIR}/bore"
readonly URL_FILE="${TEMP_DIR}/url4.tmp"
readonly LOG_FILE="${TEMP_DIR}/bore.log"
readonly LOCK_FILE="${TEMP_DIR}/tunel4.lock"
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly TIMEOUT=60

# Export for external use
export DEVICE_ID BASE_URL


#===============================================================================
# TRAP HANDLERS
#===============================================================================
cleanup() {
    local exit_code=${1:-$?}

    log "INFO" "Cleaning up processes"
    pkill -f bore 2>/dev/null || :
    rm -f "$LOG_FILE" "$URL_FILE"

    exit "$exit_code"
}


err_trap() {
    local exit_code=$? line="${BASH_LINENO[0]}" func="${FUNCNAME[1]:-main}"
    log "ERROR" "${func}():${line} failed (exit $exit_code)"
}


trap 'cleanup $?' EXIT INT TERM
trap err_trap ERR


#===============================================================================
# LOGGING
#===============================================================================
log() {
    local level="$1" msg="$2"
    local timestamp
    timestamp=$(TZ=Asia/Kuwait date '+%Y-%m-%d %H:%M:%S')
    printf '[%s] [%s] %s\n' "$timestamp" "$level" "$msg" | tee -a "$LOG_FILE"
}


#===============================================================================
# FUNCTIONS
#===============================================================================

# Get bore version (Pure Bash)
get_version() {
    local version_output
    version_output=$("$BORE_BIN" --version 2>/dev/null) || { echo "0.0.0"; return; }

    # Extract second word (version number)
    local -a words
    read -ra words <<< "$version_output"

    if [[ ${#words[@]} -ge 2 ]]; then
        echo "${words[1]}"
    else
        echo "0.0.0"
    fi
}


# Install bore with file verification
install_bore() {
    local current_version temp_file="$TEMP_DIR/bore_temp"

    if [[ -f $BORE_BIN ]]; then
        current_version=$(get_version)

        if [[ $current_version == "$MIN_VERSION" ]]; then
            log "INFO" "bore version $current_version is correct"
            return 0
        fi

        log "INFO" "Current bore version $current_version needs update to $MIN_VERSION"
    else
        log "INFO" "bore not found. Installing..."
    fi

    cd "$TEMP_DIR" || return 1

    local attempt

    for attempt in {1..3}; do
        log "INFO" "Download attempt $attempt/3 from custom source"

        if wget -q "$BASE_URL/downloads/bore" -O "$temp_file" 2>/dev/null; then
            chmod +x "$temp_file"

            # Verify file size (minimum 500KB)
            local file_size
            file_size=$(stat -c%s "$temp_file" 2>/dev/null || echo 0)

            if [[ $file_size -ge 500000 ]]; then
                sudo mv "$temp_file" "$BORE_BIN"
                log "INFO" "Successfully installed bore from custom source (${file_size} bytes)"
                return 0
            fi

            log "WARN" "Downloaded file too small ($file_size bytes), retry $attempt/3"
            rm -f "$temp_file"
        fi

        sleep 1
    done

    log "INFO" "Trying official source"
    if wget -q "https://github.com/ekzhang/bore/releases/download/v0.5.1/bore-v0.5.1-armv7-unknown-linux-gnueabihf.tar.gz" -O bore.tar.gz 2>/dev/null; then
        tar xzf bore.tar.gz
        chmod +x bore

        # Verify file size
        local file_size
        file_size=$(stat -c%s bore 2>/dev/null || echo 0)

        if [[ $file_size -ge 500000 ]]; then
            sudo mv bore "$BORE_BIN"
            rm -f bore.tar.gz
            log "INFO" "Successfully installed bore from official source (${file_size} bytes)"
            return 0
        fi
    fi

    log "ERROR" "Failed to install bore from any source"
    return 1
}


# Try server connection
try_server() {
    local server="$1" secret="$2" server_type="${3:-public}"

    # Build command
    if [[ -n $secret ]]; then
        log "INFO" "Attempting connection to custom server: $server"
        "$BORE_BIN" local "$T_PORT" --to "$server" --secret "$secret" > "$LOG_FILE" 2>&1 &
    else
        log "INFO" "Attempting connection to public server: $server"
        "$BORE_BIN" local "$T_PORT" --to "$server" > "$LOG_FILE" 2>&1 &
    fi

    local bore_pid=$!
    log "INFO" "Started bore process with PID: $bore_pid"

    local wait_count=0
    while [[ $wait_count -lt $TIMEOUT ]]; do
        # Check for "listening at" in log file
        if [[ -f $LOG_FILE ]]; then
            local log_content
            log_content=$(<"$LOG_FILE")

            if [[ $log_content == *"listening at"* ]]; then
                # Extract URL with grep or pure bash
                local url
                url=$(grep -oP 'listening at \K[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+' "$LOG_FILE" 2>/dev/null || :)

                if [[ -z "$url" ]]; then
                    # Fallback: pure bash extraction
                    local listening_line
                    while IFS= read -r line; do
                        if [[ $line == *"listening at"* ]]; then
                            listening_line="$line"
                            break
                        fi
                    done <<< "$log_content"

                    # Extract IP:PORT pattern
                    if [[ $listening_line =~ ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+) ]]; then
                        url="${BASH_REMATCH[1]}"
                    fi
                fi

                if [[ -n "$url" ]]; then
                    echo "http://$url" > "$URL_FILE"
                    log "INFO" "Successfully connected to $server_type server. URL: http://$url"

                    sleep 0.2  # Service stabilization delay
                    return 0
                fi
            fi
        fi

        if ! ps -p "$bore_pid" > /dev/null 2>&1; then
            log "WARN" "bore process $bore_pid died unexpectedly"
            break
        fi

        sleep 1
        ((wait_count++))
    done

    log "WARN" "Connection attempt to $server_type server timed out or failed"
    kill "$bore_pid" 2>/dev/null || :
    return 1
}


# Start tunnel with retry
start_tunnel() {
    local attempt

    # Clean up existing processes
    pkill -f bore 2>/dev/null || :
    rm -f "$LOG_FILE" "$URL_FILE"

    for attempt in $(seq 1 "$MAX_RETRIES"); do
        log "INFO" "Starting tunnel attempt $attempt/$MAX_RETRIES"

        # Try custom server first
        if try_server "$CUSTOM_SERVER" "$CUSTOM_SECRET" "custom"; then
            return 0
        fi

        log "WARN" "Custom server failed, trying public server"

        # Try public server as fallback
        if try_server "bore.pub" "" "public"; then
            return 0
        fi

        if [[ $attempt -lt $MAX_RETRIES ]]; then
            log "INFO" "Both servers failed. Waiting ${RETRY_DELAY}s before retry"
            sleep "$RETRY_DELAY"

            # Clean up for retry
            pkill -f bore 2>/dev/null || :
            rm -f "$LOG_FILE" "$URL_FILE"
        fi
    done

    log "ERROR" "All connection attempts failed after $MAX_RETRIES tries"
    return 1
}


# Monitor tunnel health
monitor_tunnel() {
    log "INFO" "Starting tunnel monitoring"

    while true; do
        if ! pgrep -f bore >/dev/null 2>&1; then
            log "WARN" "bore process not found, restarting tunnel"
            if ! start_tunnel; then
                log "ERROR" "Failed to restart tunnel"
            fi
        fi
        sleep 30
    done
}


#===============================================================================
# MAIN
#===============================================================================
main() {
    # Use flock to prevent multiple instances
    (
        flock -n 9 || {
            log "ERROR" "Another instance of tunel4.sh is running. Exiting."
            exit 1
        }

        log "INFO" "=== SERVER 4 (BORE) STARTING ==="

        if ! install_bore; then
            log "ERROR" "Failed to install bore. Exiting."
            exit 1
        fi

        if ! start_tunnel; then
            log "ERROR" "Failed to establish tunnel. Exiting."
            exit 1
        fi

        monitor_tunnel

    ) 9>"$LOCK_FILE"

    rm -f "$LOCK_FILE"

    # Final status check
    if [[ -s $URL_FILE ]]; then
        log "INFO" "Server 4 is running successfully"
    else
        log "ERROR" "Server 4 failed to start. Check $LOG_FILE for details"
    fi
}


main "$@"
