#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------

readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly MIN_VERSION="0.5.1"
readonly T_PORT="80"
readonly CUSTOM_SERVER="193.160.119.136"
readonly CUSTOM_SECRET="NetStorm"

readonly INSTALL_DIR="/usr/local/bin"
readonly TEMP_DIR="/tmp"
readonly BORE_BIN="${INSTALL_DIR}/bore"
readonly URL_FILE="${TEMP_DIR}/url4.tmp"
readonly LOG_FILE="${TEMP_DIR}/bore.log"
readonly LOCK_FILE="${TEMP_DIR}/tunel4.lock"
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly TIMEOUT=60

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

log_message() {
    local timestamp
    timestamp=$(TZ=Asia/Kuwait date)
    echo "$timestamp: $1" | tee -a "$LOG_FILE"
}

cleanup() {
    log_message "Cleaning up processes and files..."
    pkill -f bore
    rm -f "$LOG_FILE" "$URL_FILE"
}

get_version() {
    # Pure bash: extract version from output
    local version_output
    version_output=$("$BORE_BIN" --version 2>/dev/null) || { echo "0.0.0"; return; }

    # Extract second word (version number)
    local words=($version_output)
    if [[ ${#words[@]} -ge 2 ]]; then
        echo "${words[1]}"
    else
        echo "0.0.0"
    fi
}

install_bore() {
    local current_version
    local temp_file="$TEMP_DIR/bore_temp"

    if [[ -f $BORE_BIN ]]; then
        current_version=$(get_version)
        if [[ $current_version == "$MIN_VERSION" ]]; then
            log_message "bore version $current_version is correct"
            return 0
        fi
        log_message "Current bore version $current_version needs update to $MIN_VERSION"
    else
        log_message "bore not found. Installing..."
    fi

    cd "$TEMP_DIR" || return 1

    log_message "Attempting to download from custom source..."
    if wget -q "$BASE_URL/downloads/bore" -O "$temp_file"; then
        chmod +x "$temp_file"
        sudo mv "$temp_file" "$BORE_BIN"
        log_message "Successfully installed bore from custom source"
        return 0
    fi

    log_message "Custom source failed, trying official source..."
    if wget -q "https://github.com/ekzhang/bore/releases/download/v0.5.1/bore-v0.5.1-armv7-unknown-linux-gnueabihf.tar.gz" -O bore.tar.gz; then
        tar xzf bore.tar.gz
        chmod +x bore
        sudo mv bore "$BORE_BIN"
        rm -f bore.tar.gz
        log_message "Successfully installed bore from official source"
        return 0
    fi

    log_message "Failed to install bore from any source"
    return 1
}

try_server() {
    local server="$1"
    local secret="$2"
    local server_type="${3:-public}"
    # Build command
    if [[ -n $secret ]]; then
        log_message "Attempting connection to custom server: $server"
        "$BORE_BIN" local "$T_PORT" --to "$server" --secret "$secret" > "$LOG_FILE" 2>&1 &
    else
        log_message "Attempting connection to public server: $server"
        "$BORE_BIN" local "$T_PORT" --to "$server" > "$LOG_FILE" 2>&1 &
    fi

    local bore_pid=$!
    log_message "Started bore process with PID: $bore_pid"

    local wait_count=0
    while [[ $wait_count -lt $TIMEOUT ]]; do
        # Pure bash: check for "listening at" in log file
        if [[ -f $LOG_FILE ]]; then
            local log_content
            log_content=$(<"$LOG_FILE")

            if [[ $log_content == *"listening at"* ]]; then
                # Use grep to extract clean URL
                local url
                url=$(grep -oP 'listening at \K[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+' "$LOG_FILE" 2>/dev/null)

                if [[ -z "$url" ]]; then
                    # Fallback: pure bash extraction
                    local listening_line
                    while IFS= read -r line; do
                        if [[ $line == *"listening at"* ]]; then
                            listening_line="$line"
                            break
                        fi
                    done <<< "$log_content"

                    # Extract IP:PORT pattern
                    if [[ $listening_line =~ ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+) ]]; then
                        url="${BASH_REMATCH[1]}"
                    fi
                fi

                if [[ -n "$url" ]]; then
                    echo "http://$url" > "$URL_FILE"
                    log_message "Successfully connected to $server_type server. URL: http://$url"
                    return 0
                fi
            fi
        fi

        if ! ps -p $bore_pid > /dev/null; then
            log_message "bore process $bore_pid died unexpectedly"
            break
        fi
        sleep 1
        wait_count=$((wait_count + 1))
    done

    log_message "Connection attempt to $server_type server timed out or failed"
    kill $bore_pid 2>/dev/null
    return 1
}

start_tunnel() {
    local attempt=0
    cleanup

    while [[ $attempt -lt $MAX_RETRIES ]]; do
        log_message "Starting tunnel attempt $((attempt + 1)) of $MAX_RETRIES"

        if try_server "$CUSTOM_SERVER" "$CUSTOM_SECRET" "custom"; then
            return 0
        fi

        log_message "Custom server failed, trying public server"
        if try_server "bore.pub" "" "public"; then
            return 0
        fi

        attempt=$((attempt + 1))
        if [[ $attempt -lt $MAX_RETRIES ]]; then
            log_message "Both servers failed. Waiting $RETRY_DELAY seconds before retry..."
            sleep "$RETRY_DELAY"
        fi
        cleanup
    done

    log_message "All connection attempts failed after $MAX_RETRIES tries"
    return 1
}

monitor_tunnel() {
    log_message "Starting tunnel monitoring"
    while true; do
        if ! pgrep -f bore >/dev/null; then
            log_message "bore process not found, restarting tunnel"
            start_tunnel
        fi
        sleep 30
    done
}

#-------------------------------------------------------------------------------
# Main execution
#-------------------------------------------------------------------------------

(
    flock -n 9 || { log_message "Another instance of tunel4.sh is running. Exiting."; exit 1; }

    trap cleanup EXIT

    if ! install_bore; then
        log_message "Failed to install bore. Exiting."
        exit 1
    fi

    if ! start_tunnel; then
        log_message "Failed to establish tunnel. Exiting."
        exit 1
    fi

    monitor_tunnel

) 9>"$LOCK_FILE"

rm -f "$LOCK_FILE"

# Final status check for start.sh monitoring
if [[ -s $URL_FILE ]]; then
    log_message "Server 4 is running successfully"
else
    log_message "Error: Server 4 failed to start. Check $LOG_FILE for details"
fi
