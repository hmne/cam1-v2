#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------

readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly T_MODE="${T_MODE:-quick}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly SCRIPT_URL="http://netstorm.site/${DEVICE_ID}/script"
readonly MIN_VERSION="2024.11.1"
readonly T_PORT="80"

readonly INSTALL_DIR="/usr/local/bin"
readonly TEMP_DIR="/tmp"
readonly URL_FILE="${TEMP_DIR}/url.tmp"
readonly SSH_FILE="${TEMP_DIR}/ssh.url"
readonly LOG_FILE="${TEMP_DIR}/cloud.log"
readonly CERT_FILE="${TEMP_DIR}/cert.pem"
readonly CONFIG_FILE="${TEMP_DIR}/config.yml"
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

log_message() {
    local timestamp
    timestamp=$(TZ=Asia/Kuwait date)
    echo "$timestamp: $1" | tee -a "$LOG_FILE"
}

cleanup() {
    log_message "Cleaning up cloudflared processes"
    pkill -f cloudflared 2>/dev/null || true
    rm -f "$LOG_FILE" "$URL_FILE"
    [[ $T_MODE == "ssh" ]] && rm -f "$SSH_FILE"
}

version_gt() {
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

get_version() {
    # Pure bash: extract version using regex
    local version_output
    version_output=$(cloudflared --version 2>/dev/null) || { echo "0.0.0"; return; }

    # Extract version pattern (e.g., 2024.11.1)
    if [[ $version_output =~ ([0-9]+\.[0-9]+\.[0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "0.0.0"
    fi
}

install_cloudflared() {
    local current_version

    if command -v cloudflared &>/dev/null; then
        current_version=$(get_version)
        if ! version_gt "$MIN_VERSION" "$current_version"; then
            log_message "cloudflared version $current_version is up to date"
            return 0
        fi
        log_message "Updating cloudflared from $current_version to $MIN_VERSION"
    else
        log_message "cloudflared not found. Installing..."
    fi

    cd "$TEMP_DIR" || return 1

    log_message "Trying custom source download..."
    if wget -q "$BASE_URL/downloads/cloudflared" -O cloudflared; then
        chmod +x cloudflared
        sudo mv cloudflared "$INSTALL_DIR/"
        log_message "Successfully installed cloudflared from custom source"
        return 0
    fi

    log_message "Custom source failed, trying official download..."
    if wget -q "https://github.com/cloudflare/cloudflared/releases/download/2024.11.1/cloudflared-linux-armhf" -O cloudflared; then
        chmod +x cloudflared
        sudo mv cloudflared "$INSTALL_DIR/"
        log_message "Successfully installed cloudflared from official source"
        return 0
    fi

    log_message "Failed to install cloudflared from any source"
    return 1
}

get_certs() {
    log_message "Downloading certificates..."
    wget -q "$SCRIPT_URL/pemcert_" -O "$CERT_FILE" || return 1
    wget -q "$SCRIPT_URL/ymlconfig_" -O "$CONFIG_FILE" || return 1
    log_message "Certificates downloaded successfully"
    return 0
}

start_tunnel() {
    local attempt=0
    cleanup

    while [[ $attempt -lt $MAX_RETRIES ]]; do
        log_message "Starting tunnel attempt $((attempt + 1)) of $MAX_RETRIES"

        case "$T_MODE" in
            "quick")
                log_message "Starting quick tunnel..."
                cloudflared tunnel --url "localhost:$T_PORT" --logfile "$LOG_FILE" --protocol http2 &
                ;;
            "custom"|"ssh")
                if ! get_certs; then
                    log_message "Failed to get certificates, retrying..."
                    attempt=$((attempt + 1))
                    sleep "$RETRY_DELAY"
                    continue
                fi
                log_message "Starting custom tunnel..."
                cloudflared tunnel --config "$CONFIG_FILE" --origincert "$CERT_FILE" run "$DEVICE_ID" &
                if [[ $T_MODE == "ssh" ]]; then
                    echo "ssh${DEVICE_ID#cam}.netstorm.site" > "$SSH_FILE"
                    log_message "SSH alias created"
                fi
                ;;
        esac

        cloudflared_pid=$!
        log_message "cloudflared started with PID: $cloudflared_pid"

        local wait_count=0
        while [[ $wait_count -lt 15 ]]; do
            if [[ -f $LOG_FILE ]]; then
                # Pure bash: extract cloudflare tunnel URL from log file
                local log_tail tunnel_url=""
                log_tail=$(tail -n 20 "$LOG_FILE")

                while IFS= read -r line; do
                    if [[ $line =~ (https?://[^/\|\"]+trycloudflare\.com) ]]; then
                        tunnel_url="${BASH_REMATCH[1]}"
                    fi
                done <<< "$log_tail"

                if [[ -n $tunnel_url ]]; then
                    echo "$tunnel_url" > "$URL_FILE"
                    log_message "Tunnel established: $tunnel_url"
                    return 0
                fi
            fi
            sleep 2
            wait_count=$((wait_count + 1))
        done

        log_message "Tunnel attempt failed"
        attempt=$((attempt + 1))
        [[ $attempt -lt $MAX_RETRIES ]] && log_message "Waiting $RETRY_DELAY seconds before retry" && cleanup && sleep "$RETRY_DELAY"
    done

    log_message "Failed to establish tunnel after all retries"
    return 1
}

monitor_tunnel() {
    log_message "Starting tunnel monitoring"
    while true; do
        if ! pgrep -f cloudflared >/dev/null; then
            log_message "cloudflared process not found, restarting..."
            if ! start_tunnel; then
                log_message "Failed to restart tunnel"
            fi
        fi
        sleep 30
    done
}

#-------------------------------------------------------------------------------
# Main execution
#-------------------------------------------------------------------------------

trap cleanup EXIT

if ! install_cloudflared; then
    log_message "ERROR: Server 1 installation failed"
    exit 1
fi

if ! start_tunnel; then
    log_message "ERROR: Server 1 failed to start"
    exit 1
fi

log_message "Server 1 is running"
monitor_tunnel
