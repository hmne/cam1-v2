#!/usr/bin/env bash

#===============================================================================
# LIVE STREAMING SCRIPT
#===============================================================================
set -Eeuo pipefail


#===============================================================================
# CONFIG
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly API_ENDPOINT="${BASE_URL}/storage.php"
readonly STATUS_URL="${BASE_URL}/tmp/web_live.tmp"
readonly QUALITY_URL="${BASE_URL}/tmp/web_live_quality.tmp"

# Local file paths
readonly STATUS_FILE="/tmp/web_live.tmp"
readonly QUALITY_FILE="/tmp/web_live_quality.tmp"
readonly IMAGE_FILE="/tmp/live.jpg"
readonly LOG_FILE="/tmp/live.log"
readonly HEARTBEAT_FILE="/tmp/live_heartbeat.tmp"

# Performance tuning
readonly DEFAULT_QUALITY="480 360 8"  # Very-low default for speed
readonly CAPTURE_DELAY=0.2             # 200ms between captures (5 FPS)
readonly FAILURE_DELAY=2               # 2s delay on failure
readonly OFFLINE_CHECK_INTERVAL=5      # 5s when offline
readonly HTTP_TIMEOUT=3                # 3s HTTP timeout
readonly HEARTBEAT_INTERVAL=10         # Update heartbeat every 10 captures

# Export for external use
export DEVICE_ID BASE_URL


#===============================================================================
# TRAP HANDLERS
#===============================================================================
cleanup() {
    local exit_code=${1:-$?}

    pkill -9 raspistill 2>/dev/null || :
    [[ -f "$IMAGE_FILE" ]] && rm -f "$IMAGE_FILE" 2>/dev/null || :

    # Mark service as stopped
    echo "stopped:$(date +%s)" > "$HEARTBEAT_FILE" 2>/dev/null || :
    curl -sf -X POST --data-urlencode "file=tmp/web_live.tmp" \
        --data-urlencode "data=off" "$API_ENDPOINT" -m 2 &>/dev/null || :

    exit "$exit_code"
}


err_trap() {
    local exit_code=$? line="${BASH_LINENO[0]}" func="${FUNCNAME[1]:-main}"
    printf '[ERROR %s] %s:%s (exit %d)\n' "$(date '+%H:%M:%S')" "$func" "$line" "$exit_code" >&2
}


trap 'cleanup $?' EXIT INT TERM
trap err_trap ERR


#===============================================================================
# LOGGING (minimal for performance)
#===============================================================================
log() {
    [[ "${DEBUG:-0}" == "1" ]] || return 0
    printf '[%s] %s\n' "$(date '+%H:%M:%S')" "$1" >> "$LOG_FILE"
}


err() {
    printf '[ERROR %s] %s\n' "$(date '+%H:%M:%S')" "$1" >&2
}


#===============================================================================
# CORE FUNCTIONS
#===============================================================================

# Check if monitor.sh is active (has priority over web live)
is_monitor_active() {
    local hb now
    hb=$(curl -sf "${BASE_URL}/tmp/monitor_heartbeat.tmp" -m 2 2>/dev/null) || hb="0"

    now=$(date +%s)
    ((now - hb < 5)) && return 0 || return 1
}


# Check if web session is alive (user hasn't closed browser)
is_web_session_alive() {
    local sess now sess_ts
    sess=$(curl -sf "${BASE_URL}/tmp/web_live_session.tmp" -m 2 2>/dev/null) || return 1

    [[ -z "$sess" ]] && return 1

    sess_ts=${sess%%:*}
    now=$(date +%s)000

    ((now - sess_ts < 60000)) && return 0 || return 1
}


# Initialize service files
init_service() {
    local quality="${DEFAULT_QUALITY}"

    # Create files if missing
    [[ -f "$QUALITY_FILE" ]] || echo "$quality" > "$QUALITY_FILE"
    [[ -f "$STATUS_FILE" ]] || echo "off" > "$STATUS_FILE"
    chmod 666 "$QUALITY_FILE" "$STATUS_FILE" "$LOG_FILE" 2>/dev/null || :

    # Get server state or upload defaults
    local server_quality server_status

    server_quality=$(curl -sf "$QUALITY_URL" -m "$HTTP_TIMEOUT" 2>/dev/null) || server_quality=""
    server_status=$(curl -sf "$STATUS_URL" -m "$HTTP_TIMEOUT" 2>/dev/null) || server_status=""

    # Sync with server
    [[ -n "$server_quality" ]] && echo "$server_quality" > "$QUALITY_FILE"
    [[ -n "$server_status" ]] && echo "$server_status" > "$STATUS_FILE"

    # Upload defaults if server empty
    if [[ -z "$server_quality" ]]; then
        curl -sf -X POST --data-urlencode "file=tmp/web_live_quality.tmp" \
            --data-urlencode "data=$quality" "$API_ENDPOINT" -m "$HTTP_TIMEOUT" &>/dev/null || :
    fi

    if [[ -z "$server_status" ]]; then
        curl -sf -X POST --data-urlencode "file=tmp/web_live.tmp" \
            --data-urlencode "data=off" "$API_ENDPOINT" -m "$HTTP_TIMEOUT" &>/dev/null || :
    fi

    log "Service initialized"
}


# Get clean status from server with priority checks
fetch_status() {
    local status
    status=$(curl -sf "$STATUS_URL" -m "$HTTP_TIMEOUT" 2>/dev/null | tr -d '[:space:]') || status="off"

    # Priority 1: Monitor active -> force off
    is_monitor_active && { echo "off"; return; }

    # Priority 2: Status on but session dead -> force off
    [[ "$status" == "on" ]] && ! is_web_session_alive && { echo "off"; return; }

    # Return validated status
    [[ "$status" =~ ^(on|off)$ ]] && echo "$status" || echo "off"
}


# Get quality settings with validation
fetch_quality() {
    local quality
    quality=$(curl -sf "$QUALITY_URL" -m "$HTTP_TIMEOUT" 2>/dev/null | tr -d '\r') || return 1

    # Validate format: 3 numbers
    if [[ "$quality" =~ ^[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+$ ]]; then
        local old_quality
        old_quality=$(cat "$QUALITY_FILE" 2>/dev/null) || old_quality=""

        if [[ "$quality" != "$old_quality" ]]; then
            echo "$quality" > "$QUALITY_FILE"
            log "Quality: $quality"
        fi

        return 0
    fi

    return 1
}


# Capture and upload image
capture_image() {
    local width height quality

    # Fetch latest quality (critical for real-time updates)
    fetch_quality || :

    # Parse quality settings
    IFS=' ' read -r width height quality < "$QUALITY_FILE" 2>/dev/null || {
        IFS=' ' read -r width height quality <<< "$DEFAULT_QUALITY"
    }

    # Validate numeric values inline
    [[ "$width" =~ ^[0-9]+$ ]] || width=480
    [[ "$height" =~ ^[0-9]+$ ]] || height=360
    [[ "$quality" =~ ^[0-9]+$ ]] || quality=8

    # Capture with minimal timeout (100ms)
    raspistill -t 100 -q "$quality" -w "$width" -h "$height" -o "$IMAGE_FILE" \
        -n -awb auto -ss 33333 -sh 25 -md 0 -ae 12 -a 4 \
        -a "N.S-${DEVICE_ID^^} %Y-%m-%d %X" 2>/dev/null || return 1

    # Upload image
    curl -sf -X POST -F "upfile=@${IMAGE_FILE};type=image/jpeg" \
        "${API_ENDPOINT}?name=live.jpg" -m "$HTTP_TIMEOUT" &>/dev/null || return 1

    return 0
}


# Update heartbeat for monitoring
update_heartbeat() {
    local count="${1:-0}"

    # Update heartbeat every N captures
    if ((count % HEARTBEAT_INTERVAL == 0)); then
        date +%s > "$HEARTBEAT_FILE" 2>/dev/null || :

        # Upload heartbeat to server
        curl -sf -X POST --data-urlencode "file=tmp/live_heartbeat.tmp" \
            --data-urlencode "data=$(date +%s)" "$API_ENDPOINT" -m 2 &>/dev/null || :
    fi
}


#===============================================================================
# MAIN LOOP
#===============================================================================
main() {
    log "=== LIVE STREAMING SERVICE STARTED ==="

    init_service

    local status="off" capture_count=0 failure_count=0

    log "Service started"

    while true; do
        # Get current status from server
        local new_status
        new_status=$(fetch_status)

        # Log status changes
        if [[ "$new_status" != "$status" ]]; then
            log "Status: $status -> $new_status"
            status="$new_status"
            failure_count=0
        fi

        if [[ "$status" == "on" ]]; then
            # Live mode - capture and upload
            if capture_image; then
                ((capture_count++)) || capture_count=1
                failure_count=0
                update_heartbeat "$capture_count"
                sleep "$CAPTURE_DELAY"
            else
                ((failure_count++)) || failure_count=1

                # Exponential backoff on failures
                if ((failure_count > 5)); then
                    sleep "$FAILURE_DELAY"
                else
                    sleep "$CAPTURE_DELAY"
                fi
            fi
        else
            # Offline mode - wait and check
            capture_count=0
            sleep "$OFFLINE_CHECK_INTERVAL"
        fi
    done
}


main "$@"
