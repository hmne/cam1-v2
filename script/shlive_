#!/usr/bin/env bash

set -uo pipefail
IFS=$'\n\t'

#===============================================================================
# Constants (UPPERCASE per Google Style Guide)
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly API_ENDPOINT="${BASE_URL}/storage.php"
readonly STATUS_URL="${BASE_URL}/tmp/web_live.tmp"
readonly QUALITY_URL="${BASE_URL}/tmp/web_live_quality.tmp"

# Local file paths
readonly STATUS_FILE="/tmp/web_live.tmp"
readonly QUALITY_FILE="/tmp/web_live_quality.tmp"  
readonly IMAGE_FILE="/tmp/live.jpg"
readonly LOG_FILE="/tmp/live.log"
readonly HEARTBEAT_FILE="/tmp/live_heartbeat.tmp"

# Performance tuning
readonly DEFAULT_QUALITY="480 360 8"  # Very-low default for speed
readonly CAPTURE_DELAY=0.2             # 200ms between captures (5 FPS)
readonly FAILURE_DELAY=2               # 2s delay on failure
readonly OFFLINE_CHECK_INTERVAL=5      # 5s when offline
readonly HTTP_TIMEOUT=3                # 3s HTTP timeout
readonly HEARTBEAT_INTERVAL=10         # Update heartbeat every 10 captures

#===============================================================================
# Cleanup trap
#===============================================================================
cleanup() {
  pkill -9 raspistill 2>/dev/null || true
  # FIXED: SC2015
  if [[ -f "$IMAGE_FILE" ]]; then
    rm -f "$IMAGE_FILE" 2>/dev/null || true
  fi
  # Mark service as stopped
  echo "stopped:$(date +%s)" > "$HEARTBEAT_FILE" 2>/dev/null || true
  curl -sf -X POST -d "file=tmp/web_live.tmp" -d "data=off" "$API_ENDPOINT" -m 2 &>/dev/null || true
  exit "${1:-0}"
}
trap cleanup EXIT INT TERM

#===============================================================================
# Logging (minimal for performance)
#===============================================================================
log() { [[ "${DEBUG:-0}" == "1" ]] || return 0; printf '[%s] %s\n' "$(date '+%H:%M:%S')" "$1" >> "$LOG_FILE"; }
err() { printf '[ERROR %s] %s\n' "$(date '+%H:%M:%S')" "$1" >&2; }

#===============================================================================
# Core Functions
#===============================================================================
# Check if monitor.sh is active (has priority over web live)
is_monitor_active() {
  local hb now
  hb=$(curl -sf "${BASE_URL}/tmp/monitor_heartbeat.tmp" -m 2 2>/dev/null) || hb="0"
  now=$(date +%s)
  (( now - hb < 5 )) && return 0 || return 1
}

# Check if web session is alive (user hasn't closed browser)
is_web_session_alive() {
  local sess now sess_ts
  sess=$(curl -sf "${BASE_URL}/tmp/web_live_session.tmp" -m 2 2>/dev/null) || return 1
  [[ -z "$sess" ]] && return 1
  sess_ts=${sess%%:*}
  now=$(date +%s)000
  (( now - sess_ts < 60000 )) && return 0 || return 1
}

# Initialize service files
init_service() {
  local quality="${DEFAULT_QUALITY}"
  
  # Create files if missing
  [[ -f "$QUALITY_FILE" ]] || echo "$quality" > "$QUALITY_FILE"
  [[ -f "$STATUS_FILE" ]] || echo "off" > "$STATUS_FILE"
  chmod 666 "$QUALITY_FILE" "$STATUS_FILE" "$LOG_FILE" 2>/dev/null || true
  
  # Get server state or upload defaults
  local server_quality server_status
  server_quality=$(curl -sf "$QUALITY_URL" -m "$HTTP_TIMEOUT" 2>/dev/null) || server_quality=""
  server_status=$(curl -sf "$STATUS_URL" -m "$HTTP_TIMEOUT" 2>/dev/null) || server_status=""
  
  # Sync with server
  [[ -n "$server_quality" ]] && echo "$server_quality" > "$QUALITY_FILE"
  [[ -n "$server_status" ]] && echo "$server_status" > "$STATUS_FILE"
  
  # Upload defaults if server empty
  [[ -z "$server_quality" ]] && curl -sf -X POST -d "file=tmp/web_live_quality.tmp" -d "data=$quality" "$API_ENDPOINT" -m "$HTTP_TIMEOUT" &>/dev/null
  [[ -z "$server_status" ]] && curl -sf -X POST -d "file=tmp/web_live.tmp" -d "data=off" "$API_ENDPOINT" -m "$HTTP_TIMEOUT" &>/dev/null
  
  log "Service initialized"
}

# Get clean status from server with priority checks
fetch_status() {
  local status
  status=$(curl -sf "$STATUS_URL" -m "$HTTP_TIMEOUT" 2>/dev/null | tr -d '[:space:]') || status="off"

  # Priority 1: Monitor active -> force off
  is_monitor_active && { echo "off"; return; }

  # Priority 2: Status on but session dead -> force off
  [[ "$status" == "on" ]] && ! is_web_session_alive && { echo "off"; return; }

  # Return validated status
  [[ "$status" =~ ^(on|off)$ ]] && echo "$status" || echo "off"
}

# Get quality settings with validation
fetch_quality() {
  local quality
  quality=$(curl -sf "$QUALITY_URL" -m "$HTTP_TIMEOUT" 2>/dev/null | tr -d '\r') || return 1
  
  # Validate format: 3 numbers
  if [[ "$quality" =~ ^[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+$ ]]; then
    local old_quality
    old_quality=$(cat "$QUALITY_FILE" 2>/dev/null) || old_quality=""
    [[ "$quality" != "$old_quality" ]] && { echo "$quality" > "$QUALITY_FILE"; log "Quality: $quality"; }
    return 0
  fi
  return 1
}

# Capture and upload image
capture_image() {
  local width height quality
  
  # Fetch latest quality (critical for real-time updates)
  fetch_quality || true
  
  # Parse quality settings
  IFS=' ' read -r width height quality < "$QUALITY_FILE" 2>/dev/null || {
    IFS=' ' read -r width height quality <<< "$DEFAULT_QUALITY"
  }
  
  # Validate numeric values inline
  [[ "$width" =~ ^[0-9]+$ ]] || width=480
  [[ "$height" =~ ^[0-9]+$ ]] || height=360
  [[ "$quality" =~ ^[0-9]+$ ]] || quality=8
  
  # Capture with minimal timeout (100ms)
  raspistill -t 100 -q "$quality" -w "$width" -h "$height" -o "$IMAGE_FILE" \
    -n -awb auto -ss 33333 -sh 25 -md 0 -ae 12 -a 4 \
    -a "N.S-${DEVICE_ID^^} %Y-%m-%d %X" 2>/dev/null || return 1
  
  # Upload image
  curl -sf -X POST -F "upfile=@${IMAGE_FILE};type=image/jpeg" \
    "${API_ENDPOINT}?name=live.jpg" -m "$HTTP_TIMEOUT" &>/dev/null || return 1
  
  return 0
}

# Update heartbeat for monitoring
update_heartbeat() {
  local count="${1:-0}"
  # Update heartbeat every N captures (just timestamp, no prefix)
  if (( count % HEARTBEAT_INTERVAL == 0 )); then
    # FIXED: SC2005 - useless echo
    date +%s > "$HEARTBEAT_FILE" 2>/dev/null || true
    # Optional: Upload heartbeat to server
    curl -sf -X POST -d "file=tmp/live_heartbeat.tmp" -d "data=$(date +%s)" \
      "$API_ENDPOINT" -m 2 &>/dev/null || true
  fi
}

#===============================================================================
# Main Loop
#===============================================================================
main() {
  init_service
  
  local status="off" capture_count=0 failure_count=0
  
  log "Service started"
  
  while true; do
    # Get current status from server
    local new_status
    new_status=$(fetch_status)
    
    # Log status changes
    [[ "$new_status" != "$status" ]] && { 
      log "Status: $status -> $new_status"
      status="$new_status"
      failure_count=0
    }
    
    if [[ "$status" == "on" ]]; then
      # Live mode - capture and upload
      if capture_image; then
        ((capture_count++))
        failure_count=0
        update_heartbeat "$capture_count"
        sleep "$CAPTURE_DELAY"
      else
        ((failure_count++))
        # Exponential backoff on failures (FIXED: SC2015)
        if (( failure_count > 5 )); then
          sleep "$FAILURE_DELAY"
        else
          sleep "$CAPTURE_DELAY"
        fi
      fi
    else
      # Offline mode - wait and check
      capture_count=0
      sleep "$OFFLINE_CHECK_INTERVAL"
    fi
  done
}

# Execute main function
main "$@"
