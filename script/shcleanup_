#!/usr/bin/env bash

#===============================================================================
# CLEANUP SCRIPT - System Maintenance and Process Monitoring
#===============================================================================
set -Eeuo pipefail


#===============================================================================
# CONFIG
#===============================================================================
readonly DEVICE_ID="${DEVICE_ID:-cam1}"
readonly BASE_URL="http://netstorm.site/${DEVICE_ID}"
readonly VERSION="2.0.0"

# Export for external use
export DEVICE_ID BASE_URL VERSION

# Get MAC address for logging
get_mac_address() {
    local mac_file="/sys/class/net/wlan0/address"
    if [[ -r "$mac_file" ]]; then
        cat "$mac_file"
    elif command -v ip &>/dev/null; then
        local ip_output
        ip_output=$(ip link show wlan0 2>/dev/null)
        if [[ $ip_output =~ link/ether[[:space:]]+([0-9a-f:]+) ]]; then
            echo "${BASH_REMATCH[1]}"
        else
            echo "unknown"
        fi
    else
        echo "unknown"
    fi
}

MAC_ADDRESS=""
MAC_ADDRESS=$(get_mac_address)
readonly MAC_ADDRESS


#===============================================================================
# TRAP HANDLERS
#===============================================================================
cleanup() {
    local exit_code=${1:-$?}
    exit "$exit_code"
}


err_trap() {
    local exit_code=$? line="${BASH_LINENO[0]}" func="${FUNCNAME[1]:-main}"
    log_web "ERROR" "${func}():${line} failed (exit $exit_code)"
}


trap 'cleanup $?' EXIT INT TERM
trap err_trap ERR


#===============================================================================
# LOGGING
#===============================================================================
log() {
    printf '[%s] [%s] %s\n' "$(date '+%H:%M:%S')" "$1" "$2"
}


log_web() {
    local status="$1" message="$2"
    local timestamp log_data attempt

    timestamp=$(TZ=Asia/Kuwait date '+%d/%m/%Y %H:%M:%S')
    log_data="[ $status ] $message | Device: $MAC_ADDRESS | $timestamp"

    for attempt in {1..2}; do
        if curl -sf --max-time 5 --data-urlencode "file=log/log.txt" \
            --data-urlencode "data=$log_data" "${BASE_URL}/storage.php" >/dev/null 2>&1; then

            # Update status.tmp to show last activity
            local unix_time
            printf -v unix_time '%(%s)T' -1
            curl -sf --max-time 1 --data-urlencode "file=tmp/status.tmp" \
                --data-urlencode "data=active $unix_time" \
                "${BASE_URL}/storage.php" >/dev/null 2>&1 || :

            [[ $attempt -gt 1 ]] && log "INFO" "Web log succeeded on attempt $attempt"
            return 0
        fi
        sleep 1
    done

    return 1
}


#===============================================================================
# FUNCTIONS
#===============================================================================

# Get disk usage percentage (Pure Bash)
get_disk_usage() {
    local df_output line_count=0 usage_line
    df_output=$(df -h / 2>/dev/null || echo "")

    [[ -z $df_output ]] && { echo "0"; return; }

    while IFS= read -r line; do
        ((line_count++))
        if [[ $line_count -eq 2 ]]; then
            usage_line="$line"
            break
        fi
    done <<< "$df_output"

    # Extract 5th field (Usage%) and remove % sign
    local -a fields
    read -ra fields <<< "$usage_line"
    local usage="${fields[4]:-0%}"
    echo "${usage%\%}"
}


# Clean up duplicate files using mapfile
cleanup_duplicates() {
    local dir="$1" pattern="$2"

    if [[ ! -d $dir ]]; then
        return 0
    fi

    local -a dup_files
    mapfile -t dup_files < <(find "$dir" -type f -name "${pattern}.*[0-9]" 2>/dev/null || :)

    local count=${#dup_files[@]}
    if [[ $count -gt 0 ]]; then
        find "$dir" -type f -name "${pattern}.*[0-9]" -delete 2>/dev/null || :
        log "INFO" "Cleaned $count duplicate files in $dir"
    fi
}


# Restart process if not running
restart_process() {
    local process=$1

    if ! pgrep -f "${process}.sh" >/dev/null 2>&1; then
        log "WARN" "${process}.sh not running, restarting"
        log_web "RESTART" "${process}.sh restarted"

        if [[ -f /tmp/${process}.sh ]]; then
            /tmp/"${process}.sh" > /tmp/"${process}.log" 2>&1 &
            sleep 0.1  # Service startup delay
        else
            log "ERROR" "Cannot restart ${process}.sh - file not found"
        fi
    fi
}


#===============================================================================
# MAIN
#===============================================================================
main() {
    log "INFO" "=== CLEANUP SERVICE STARTED ==="
    log_web "INFO" "Cleanup Service Started"

    # Safe cleanup of temporary files
    log "INFO" "Cleaning old temporary files"
    find /tmp -name "*.tmp" -type f -mtime +7 -delete 2>/dev/null || :
    find /tmp -name "*.log" -type f -mtime +7 -delete 2>/dev/null || :

    # Clean up duplicate files in parallel
    cleanup_duplicates "/var/www/html" "*.jpg" &
    cleanup_duplicates "/var/www/html" "*.css" &
    cleanup_duplicates "/var/www/html" "*.js" &
    cleanup_duplicates "/var/www/html" "*.ico" &
    wait

    # Check disk space
    local disk_usage
    disk_usage=$(get_disk_usage)

    log "INFO" "Disk usage: ${disk_usage}%"

    if [[ $disk_usage -gt 80 ]]; then
        log "WARN" "Disk usage high (${disk_usage}%), performing deep cleanup"
        log_web "WARN" "Disk High: ${disk_usage}%"

        # Remove large old files
        find /tmp -type f -size +10M -mtime +3 -delete 2>/dev/null || :

        # System cleanup
        if command -v journalctl &>/dev/null; then
            sudo journalctl --vacuum-time=2d 2>/dev/null || :
        fi

        # Clear apt cache
        if command -v apt-get &>/dev/null; then
            sudo apt-get clean 2>/dev/null || :
        fi

        # Check new disk usage
        local new_disk_usage
        new_disk_usage=$(get_disk_usage)
        log "INFO" "Disk usage after cleanup: ${new_disk_usage}%"
        log_web "INFO" "Disk After Cleanup: ${new_disk_usage}%"
    fi

    # Check for broken symlinks
    local -a broken_links
    mapfile -t broken_links < <(find /var/www/html -type l -xtype l 2>/dev/null || :)

    local broken_count=${#broken_links[@]}
    if [[ $broken_count -gt 0 ]]; then
        log "WARN" "Found $broken_count broken symlinks, removing"
        log_web "WARN" "Broken Symlinks: $broken_count"
        find /var/www/html -type l -xtype l -delete 2>/dev/null || :
    fi

    # Restart critical processes in parallel
    log "INFO" "Checking critical processes"

    restart_process "tunel" &
    restart_process "tunel2" &
    restart_process "tunel3" &
    restart_process "tunel4" &
    restart_process "sync" &
    restart_process "main" &
    restart_process "live" &
    wait

    log "INFO" "Cleanup completed successfully"
    log_web "OK" "Cleanup Completed"

    exit 0
}


main "$@"
